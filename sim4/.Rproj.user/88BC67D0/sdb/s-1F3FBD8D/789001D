{
    "contents" : "# est.dr = function(dat,sd=FALSE)\n# {\n#   glm.fit = glm(Y~.,data=dat, family=\"binomial\")\n#   new.data=cbind(X=1,dat[,-c(1:2)])\n#   pr1 = predict(glm.fit,newdata=new.data)\n#   pr1 = exp(pr1)/(1+exp(pr1))\n#   new.data=cbind(X=0,dat[,-c(1:2)])\n#   pr0 = predict(glm.fit,newdata=new.data)\n#   pr0 = exp(pr0)/(1+exp(pr0))\n#   glm.fit = glm(X~.,data=dat[,-1], family=\"binomial\")\n#   prp = fitted(glm.fit)\n#   Y = dat$Y\n#   X= dat$X\n#   \n#   est1 = mean( (Y*X - (X-prp)*pr1)/prp )\n#   est0 = mean( (Y*(1-X) + (X-prp)*pr0)/(1-prp)) \n#   est.dr = est1 - est0  \n#   ## sandwich se\n#   if (sd) {sd.dr = sqrt(sum(((Y*X - (X-prp)*pr1)/prp - (Y*(1-X) + (X-prp)*pr0)/(1-prp)-est.dr)^2)/nrow(dat)^2)} else {sd.dr=NULL}\n#   \n#   list(est.dr=est.dr,sd.dr=sd.dr)\n#   #c(est.dr,est1=est1,est0=est0)\n# }\n\nest.dr = function(dat,sd=FALSE)\n{ \n  require(speedglm)\n  #glm.fit = glm(Y~.,data=dat, family=\"binomial\")\n  forglm=as.formula(\n    paste(\"Y ~ X +\",paste(\"C\",1:(ncol(dat)-2),collapse=\"+\",sep=\"\"))\n  )\n  glm.fit2=speedglm(forglm,data=dat,family=binomial())\n  \n  new.data=cbind(int=1,X=1,dat[,grep(\"C\",names(dat))])\n  pr1 <- inv.logit(as.matrix(new.data)%*%as.matrix(coef(glm.fit2)))\n  new.data=cbind(int=1,X=0,dat[,grep(\"C\",names(dat))])\n  pr0 <- inv.logit(as.matrix(new.data)%*%as.matrix(coef(glm.fit2)))\n  \n  forglm=as.formula(\n    paste(\"X ~\",paste(\"C\",1:(ncol(dat)-2),collapse=\"+\",sep=\"\"))\n  )\n  glm.fit = glm(forglm,data=dat[,-grep(\"Y\",names(dat))], family=binomial())\n  \n  new.data=cbind(int=1,dat[,grep(\"C\",names(dat))])\n  prp  <- inv.logit(as.matrix(new.data)%*%as.matrix(coef(glm.fit)))\n   \n  Y = dat$Y\n  X= dat$X\n  \n  est1 = mean( (Y*X - (X-prp)*pr1)/prp )\n  est0 = mean( (Y*(1-X) + (X-prp)*pr0)/(1-prp)) \n  est.dr = est1 - est0  \n  ## sandwich se\n  if (sd) {sd.dr = sqrt(sum(((Y*X - (X-prp)*pr1)/prp - (Y*(1-X) + (X-prp)*pr0)/(1-prp)-est.dr)^2)/nrow(dat)^2)} else {sd.dr=NULL}\n  \n  list(est.dr=est.dr,sd.dr=sd.dr)\n  #c(est.dr,est1=est1,est0=est0)\n}\n\n\nsd.bs <- function(dat,B=1000)\n{\n  pb = txtProgressBar(min=0,max=B,style=3)\n  est.boos = do.call(rbind,lapply(1:B,function(x)\n  {\n    b.sample = sample(1:nrow(dat),size=nrow(dat),replace=TRUE)\n    dr= est.dr(dat[b.sample,])$est.dr\n    X = dat[b.sample,\"X\"]\n    Y = dat[b.sample,\"Y\"]\n    C = dat[b.sample,paste0(\"C\",1:(ncol(dat)-2))]\n    setTxtProgressBar(pb,x)\n    est = as.vector(bay.est.old(Y,X,C)$est)\n    return(c(dr,sold=est[1],P=est[2],Bold=est[3]))\n  }))\n  \n  est.sd = as.vector(apply(est.boos,2,sd))\n  list(dr.sd=est.sd[1],sold.sd=est.sd[2],P.sd=est.sd[3],Sold.sd=est.sd[4])\n}\n\n\nsat2 <- function(Y,X,C,k_q,mean,BinMean,con,BinCon,addBin,kappa,beta,Mc.error,liketype,Dat)\n{\n  if (missing(Y)|missing(X)|missing(C)) {Y=Dat$Y;X=Dat$X;C=Dat[,paste0(\"C\",1:(ncol(Dat)-2))]}\n  if (missing(Dat)&(missing(Y)|missing(X)|missing(C))) stop(\"Data entry wrong Y or X or C or Dat is missing\") \n  if (missing(k_q)) k_q=1\n  if (missing(mean)) mean=c(0.01,0.99)\n  if (missing(con)) con=c(1,20)\n  if (missing(BinMean)) BinMean=20\n  if (missing(BinCon)) BinCon=20\n  if (missing(beta)) beta=30^2*diag(rep(1,ncol(C)+2))\n  if (missing(Mc.error)) Mc.error=0.001\n  if (missing(kappa)) kappa=0.5\n  if (missing(addBin)) addBin=c(0,10)\n  if (missing(liketype)) liketype=\"bernoulli\"\n  \n  temp.p = para.est(Y,X,C,beta=beta,k_q=k_q,Mc.error=Mc.error)\n  estimate.p = temp.p$P\n  likelihood.p=temp.p$likelihood\n  \n  temp.s0 <- sat.est.old(Y,X,C)\n  likelihood0 = temp.s0$likelihood.old\n  estimate.s0 = temp.s0$est.old\n  \n  ratio.likelihood0<- exp(likelihood0 - likelihood.p)\n  w0 <- kappa/(kappa+(1-kappa)*ratio.likelihood0)\n  estimate.b0 <- w0*estimate.p+(1-w0)*estimate.s0 # bayesian estimate for hirarchical version\n  \n  temp.s1 <- sat.est.new(Y,X,C,k_q,mean,BinMean,con,BinCon,addBin=addBin[1],liketype=liketype)\n  likelihood1 = temp.s1$likelihood.new\n  estimate.s1 = temp.s1$est.new\n  \n  ratio.likelihood1<- exp(likelihood1 - likelihood.p)\n  w1 <- kappa/(kappa+(1-kappa)*ratio.likelihood1)\n  estimate.b1 <- w1*estimate.p+(1-w1)*estimate.s1 # bayesian estimate for hirarchical version\n  \n  temp.s2 <- sat.est.new(Y,X,C,k_q,mean,BinMean,con,BinCon,addBin=addBin[2],liketype=liketype)\n  likelihood2 = temp.s2$likelihood.new\n  estimate.s2 = temp.s2$est.new\n  \n  ratio.likelihood2<- exp(likelihood2 - likelihood.p)\n  w2 <- kappa/(kappa+(1-kappa)*ratio.likelihood2)\n  estimate.b2 <- w2*estimate.p+(1-w2)*estimate.s2 #\n  \n  \n  return(\n    list(est=c(\n               P=estimate.p,  \n               S0=estimate.s0, \n               B0=estimate.b0,\n               S1=estimate.s1,\n               B1=estimate.b1,\n               S2=estimate.s2,\n               B2=estimate.b2\n               ),\n         likelihood=c(l.p=likelihood.p,l.S0=likelihood0,l.S1=likelihood1,S2=likelihood2)    \n    )\n  )  \n}\n\n\nsimFun <- function(Dat)\n{\n  #source(\"Fun.R\")\n  dr = est.dr(Dat)$est.dr\n  require(BayDR)\n  est = as.vector(try(sat2(Dat=Dat)$est))\n#   bay1 = as.vector(try(bay.est.new(Dat=Dat,addBin=0)$est))\n#   bay2 = as.vector(try(bay.est.new(Dat=Dat)$est))\n  \n  \n  if (!is.numeric(est)) est=rep(NA,length(est))\n  res  = c(dr = dr,s0=est[2],p=est[1],b0=est[3],s1 =est[4],\n             b1 = est[5],s2 =est[6],\n           b2=est[7],\n           r=ncol(Dat)-2)\n  gc()\n  return(res)\n}\n",
    "created" : 1373795246916.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3975736046",
    "id" : "789001D",
    "lastKnownWriteTime" : 1374085190,
    "path" : "~/Dropbox/UBC/Thesis/Simulation_Thesis/sim4/Fun.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}