{
    "contents" : "# est.dr = function(dat,sd=FALSE)\n# {\n#   glm.fit = glm(Y~.,data=dat, family=\"binomial\")\n#   new.data=cbind(X=1,dat[,-c(1:2)])\n#   pr1 = predict(glm.fit,newdata=new.data)\n#   pr1 = exp(pr1)/(1+exp(pr1))\n#   new.data=cbind(X=0,dat[,-c(1:2)])\n#   pr0 = predict(glm.fit,newdata=new.data)\n#   pr0 = exp(pr0)/(1+exp(pr0))\n#   glm.fit = glm(X~.,data=dat[,-1], family=\"binomial\")\n#   prp = fitted(glm.fit)\n#   Y = dat$Y\n#   X= dat$X\n#   \n#   est1 = mean( (Y*X - (X-prp)*pr1)/prp )\n#   est0 = mean( (Y*(1-X) + (X-prp)*pr0)/(1-prp)) \n#   est.dr = est1 - est0  \n#   ## sandwich se\n#   if (sd) {sd.dr = sqrt(sum(((Y*X - (X-prp)*pr1)/prp - (Y*(1-X) + (X-prp)*pr0)/(1-prp)-est.dr)^2)/nrow(dat)^2)} else {sd.dr=NULL}\n#   \n#   list(est.dr=est.dr,sd.dr=sd.dr)\n#   #c(est.dr,est1=est1,est0=est0)\n# }\n\nest.dr = function(dat,sd=FALSE)\n{ \n  require(speedglm)\n  #glm.fit = glm(Y~.,data=dat, family=\"binomial\")\n  forglm=as.formula(\n    paste(\"Y ~ X +\",paste(\"C\",1:(ncol(dat)-2),collapse=\"+\",sep=\"\"))\n  )\n  glm.fit2=speedglm(forglm,data=dat,family=binomial())\n  \n  new.data=cbind(int=1,X=1,dat[,-c(1:2)])\n  pr1 <- inv.logit(as.matrix(new.data)%*%as.matrix(coef(glm.fit2)))\n  new.data=cbind(int=1,X=0,dat[,-c(1:2)])\n  pr0 <- inv.logit(as.matrix(new.data)%*%as.matrix(coef(glm.fit2)))\n  \n  forglm=as.formula(\n    paste(\"X ~\",paste(\"C\",1:(ncol(dat)-2),collapse=\"+\",sep=\"\"))\n  )\n  glm.fit = glm(forglm,data=dat[,-1], family=binomial())\n  \n  new.data=cbind(int=1,dat[,-c(1:2)])\n  prp  <- inv.logit(as.matrix(new.data)%*%as.matrix(coef(glm.fit)))\n   \n  Y = dat$Y\n  X= dat$X\n  \n  est1 = mean( (Y*X - (X-prp)*pr1)/prp )\n  est0 = mean( (Y*(1-X) + (X-prp)*pr0)/(1-prp)) \n  est.dr = est1 - est0  \n  ## sandwich se\n  if (sd) {sd.dr = sqrt(sum(((Y*X - (X-prp)*pr1)/prp - (Y*(1-X) + (X-prp)*pr0)/(1-prp)-est.dr)^2)/nrow(dat)^2)} else {sd.dr=NULL}\n  \n  list(est.dr=est.dr,sd.dr=sd.dr)\n  #c(est.dr,est1=est1,est0=est0)\n}\n\n\nsd.bs <- function(dat,B=1000)\n{\n  pb = txtProgressBar(min=0,max=B,style=3)\n  est.boos = do.call(rbind,lapply(1:B,function(x)\n  {\n    b.sample = sample(1:nrow(dat),size=nrow(dat),replace=TRUE)\n    dr= est.dr(dat[b.sample,])$est.dr\n    X = dat[b.sample,\"X\"]\n    Y = dat[b.sample,\"Y\"]\n    C = dat[b.sample,paste0(\"C\",1:(ncol(dat)-2))]\n    setTxtProgressBar(pb,x)\n    est = as.vector(bay.est.old(Y,X,C)$est)\n    return(c(dr,sold=est[1],P=est[2],Bold=est[3]))\n  }))\n  \n  est.sd = as.vector(apply(est.boos,2,sd))\n  list(dr.sd=est.sd[1],sold.sd=est.sd[2],P.sd=est.sd[3],Sold.sd=est.sd[4])\n}\n\nsimFun <- function(Dat)\n{\n  #source(\"Fun.R\")\n  dr = est.dr(Dat)$est.dr\n  require(BayDR)\n  bay0 = as.vector(try(bay.est.old(Dat=Dat)$est))\n  bay1 = as.vector(try(bay.est.new(Dat=Dat,addBin=0)$est))\n  bay2 = as.vector(try(bay.est.new(Dat=Dat)$est))\n  \n  \n  if (!(is.numeric(bay0)&is.numeric(bay1)&is.numeric(bay2))) bay0=bay1=bay2=rep(NA,3)\n  res  = c(dr = dr,s0=bay0[1],p0=bay0[2],b0=bay0[3],s1 =bay1[1],\n           p1 = bay1[2], b1 = bay1[3],s2 =bay2[1],\n           p1 = bay2[2], b2 = bay2[3],\n           r=ncol(Dat)-2)\n  gc()\n  return(res)\n}\n",
    "created" : 1373692696164.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2992557497",
    "id" : "B6E57D9A",
    "lastKnownWriteTime" : 1373692899,
    "path" : "~/Dropbox/UBC/Thesis/Simulation_Thesis/SIm3/Fun.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}